图算法相关：
图的表示：
1. 邻接矩阵
2. 边的数组
3. 邻接表数组

1. 深度优先搜索
    1. 用一个marked数组来保存已经访问过的节点
    2. 递归遍历每个节点
    3. 可用栈来实现递归思想
2. 深度优先搜索查找路径
    1. 判断marked是否为true
    2. 在遍历时用一个数组保存当前到达遍历节点的节点是哪个，之后在反向输出
3. 深度优先搜索查找所有连通分量
    1. 用一个数组id来存储节点所在层
    2. 用count计数来计算当前顶点可以达到的所有点，记为一层
    3. 判断两个节点的id是否相等
    4. 其本质是以一个顶点为根节点，遍历其所有可以达到的顶点，然后可以构建一棵树，之后判断两个顶点是否在一棵树上。
    5. 类比union-find算法：
        1. 理论上深度优先搜索比union-find要快，因为它能保证所需的时间是常数而union-find则不行，但实际应用中，差异不大。union-find其实更快，因为它不需要完整的构造一幅图，而且它是一种动态算法（我们在任何时候都能用接近常数的时间检查两个点是否连通，甚至在添加一条边的时候），但深度优先搜索则必须重新勾画图。所以对已有结果，考虑DFS，对于操作频繁的，考虑union-find。
        2. 算法实现：
            1. 定义两个函数，find和union，find用于返回属于哪棵树，union用于将两个节点相连
            2. 定义辅助数组，保存哪个节点属于哪棵树
            3. quick-find
                1. find直接返回树的标记
                2. union遍历辅助数组，将p、q的所有标记换为相同
            4. quick-union
                1. find用于找到标识（根节点），直接查找辅助数组
                2. union直接将根节点改为相同
                3. 比较于quick-find，每次不需要遍历整个辅助数组，而是沿路径向上寻找根节点
                4. 本质是保存了一个根节点的树，find找到所属树的根节点，union将两棵树做归并
            5. 加权quick-union
                1. 多了一个表示树高的数组
                2. find同quick-union
                3. union做了加权处理，即每次不是任意将一棵树和另一棵树做归并，而是在比较两棵树的高度之后将小树归并到大树上
                4. 比quick-union的好处在于，可以保证两棵树归并的平衡，这样在find时可以更快的找到根节点，其思想是尽量保持一颗树的平衡
            6. 理解三种算法时，可以结合数据结构考虑
                1. find和union本质上没有查别，都是先查找，再替换
                2. quick-find只是一个普通的数组，每次union需要遍历整个数组
                3. quick-union通过构造树结构，来优化每次find的时间，但其构造树时未考虑其平衡性
                4. 加权quick-union也是构造树，但在归并时，考虑了平衡性，类比与二叉平衡树
4. 广度优先搜索
    1. 用队列实现
    2. 用一个marked数组来保存已经访问过的节点
5. 广度优先搜索查找路径
    1. 同深度优先搜索
6. 检测图中是否有环
    1. 给DFS加一个参数，表示当前的顶点，然后做DFS，遍历一个新的顶点时，如果已经遍历过，判断其是否等于当前顶点。
7. 双色问题
    1. 设置一个表示颜色的数组，保存每个顶点的颜色
    2. 做DFS时，每个顶点和与其相邻的顶点做颜色的！操作，如果已经遍历过，判断颜色和当前颜色是否相同。
8. 找到社交网络中两个人间隔的度数
    1. 等价于找最短路径


有向图
相比无向图，每条路径多了方向，所以多了一个可以找到路径两个顶点的函数，数据结构和无向图大同小异

1. 有向图的可达性，是否存在一条从s到达给定顶点v的有向路径
    1. 深度优先搜索可以搞定，前提是数据结构里面存好当前顶点可以到达的顶点
    2. 可应用与清理垃圾，一个顶点代表一个对象，一条边代表一个引用，JAVA就是这么做的哦
2. 有向图中的环
    1. 深度优先搜索
        1. 和无向图中查找环有什么区别呢？无向图查找时，我们给DFS加了一个参数，表示当前的顶点，然后在此节点下做DFS，如果重新找到这个点则有环，遍历所有顶点，因为每条路径是双向的，所以我们可以直接判断当前的节点和与其相连的节点是否成环。对于有向图，路径是单向的，我们不能保证从一个节点的路径可以同样返回这个节点，所以对于有向图中环的判断：
            1. 增加了一个记录当前路径上遍历过的节点的数组，当新遍历的节点已经访问过，则判断是否在路径中，同时在遍历结束之后将记录这个路径的数组元素重置，不要影响下一轮DFS的判断
            2. 这种方法类似于回溯法，每次走完之后回溯到当前状态的上一个状态。
    2. 一个典型的应用就是：优先级下的调度问题，这里引申出一中排序方法，即拓扑排序，拓扑排序：给定一幅有向图，将所有顶点排序，使得所有的有向边均从排在最前面的元素指向排在后面的元素。
    3. 拓扑排序并不难，只需在DFS中添加一行代码！其实我们的DFS遍历时就是按照优先级去遍历的，即路径的指向。完成拓扑排序，就是要完成如何去记录我们DFS走过的路径。
        1. 前序，在递归调用前将顶点加入队列
        2. 后序，在递归调用后将顶点加入队列
        3. 逆后序，在递归调用后将顶点压入栈，即为拓扑排序！为什么呢？因为后序意味着最高优先级的节点先存放，而且当前的路径是依次保存在栈中，栈意味着最先放入的最后出栈，这不就是满足拓扑排序的条件吗？
        4. 类比于二叉树的前序、后序。
3. 有向图的强连通性
    1. 意思是当且仅当两个顶点都在一个有向环中
    2. Kosaraju算法
        1. 对比于无向图中查找所有连通分量，只需要在那个基础上做少许改动
            1. 用DFS对图做逆后序排列
            2. 用逆后序排列的顺序去做类似于无向图的查找
        2. 逆后序排列意味着什么？意味着在遍历节点时，我们优先遍历优先级最低节点，然后将这个节点可以达到的所有节点标记为一层，想象一棵树，这棵树的根节点就是优先级最低的节点，然后向高处生长，如果没有逆后序排列，我们也可以从某个树枝向上生长，但当比树枝低的节点遍历到这个树枝时，我们又要重新遍历这个树枝才能将他们置于一层，做了无用功。

最小生成树（无向图）
图的生成树是它的一棵含有所有顶点的无环连通子图，一副加权图的最小生成树（MST）是它的权值最小的生成树。权重不一定是距离，也可能是0或者负数，其实就是每条路径多了一个和路径关联的值。
找最小生成树之前，先介绍一个定理。
切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树。
切分定理是所有解决最小生成树问题的基础。这些算法都是贪心算法，即每次切分找最优，之后继续切分。

1. Prim算法
    1. 用一个数组表示已经加入到树中的顶点
    2. 需要用一个优先队列来保存我们当前的所有边的权重，优先队列可以保证每次很快的去到最小的权重的边
    3. 要维护一个包含所有横切边的集合，就要将连接这个顶点和其他所有不在树中的顶点的边加入优先队列，同时新加入树中的顶点和已在树中的顶点的边要从优先队列中删掉
    4. 有了以上的数据结构和考量，我们可以实现Prim算法了。
        1. 每次从优先队列选出最小边，将边加入最小生成树的队列中
        2. 遍历边的两个顶点，如果都访问过，跳过，直到优先队列为空
        3. 这里，我们可以从优先队列中选择删除已有顶点的边，但每次加入新顶点都要遍历一次优先队列，似乎并不能优化算法速度，其实还有更简单的方法，除了删除已有顶点的边，我们可以删除更多的边。关键在于，我们感兴趣的只有连接树顶点和非树顶点中权重最小的边。那么我们在一条新的边加入优先队列时就考虑其是否需要加入优先队列就可以了！以下是Prim的即时算法：
            1. 设置两个新数组，edgeTo[v]表示连接顶点v和树之间的边（只有一条，权重最小的那条边），destTo[v]表示到v的最小权重
            2. 我们不在需要marked数组来标记是否访问过顶点了，直接将destTo初始化为INT_MAX，即表示没有遍历到
            3. 每次从优先队列选出最小边，将最小边加入MST中
            4. 遍历与顶点相连的所有边和其顶点w，如果已经在树中，跳过，否则
                1. 如果这条边的权重小于到distTo[w]，则更新distTo[w]的值，并判断其是否在优先队列中，如果没有则插入，有则更新。
            5. 直到优先队列为空
        4. 和未优化版本的prim算法相比，每次优先队列中只保存了一条到未加入MST的顶点的边，我们每次只是更新或添加，所以可能在时间并未太过明显，但空间大大提升了。
2. Kruskal算法
    1. 这个算法思想是按照边的权重，将边加入MST，并保证加入的边和已有的边不会构成环，直到MST中有V-1条边为止，也是贪心算法，每次加入的边都是MST中边，即最优。
    2. 可见，算法的难点在于判断新加入的边是否构成了环，回想之前判断无向图的环的算法，我们很容易实现Kruskal算法。
    3. 将所有的边加入优先队列
    4. 依次弹出优先队列的最小边，判断边的两个顶点是否连通，如果连通，跳过，否则union两个顶点
    5. 将这条边加入MST
    6. 看着比prim简单多了

最短路径（有向图）
对应于加权有向图，选择连接两个顶点的权重最小的路径

